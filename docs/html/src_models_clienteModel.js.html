<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/models/clienteModel.js</title>

    <script src="../scripts/prettify/prettify.js"> </script>
    <script src="../scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="../styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="../styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/models/clienteModel.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { pool } = require('../config/db');

/**
 * Modelo responsável por gerenciar o acesso ao banco de dados para a tabela Clientes
 * e suas tabelas relacionadas (Endereços e Telefones).
 * @module models/clienteModel
 */
const clienteModel = {

    /**
     * Busca todos os clientes cadastrados com seus respectivos endereços e telefones.
     * Realiza JOINs entre as tabelas clientes, endereços e telefones.
     * @async
     * @function listarCliente
     * @returns {Promise&lt;Array&lt;Object>>} Retorna uma lista de objetos contendo dados do cliente, endereço e telefone.
     */
    listarCliente: async () => {
        const sql =
            `SELECT 
	            id_cliente, 
	            nome, 
	            cpf, 
	            email, 
	            ender.cep, 
                ender.numero,
                ender.complemento,
	            tel.telefone
            FROM clientes cli
            join enderecos ender on cli.id_cliente = ender.clientes_id_cliente
            join telefones tel on cli.id_cliente = tel.clientes_id_cliente;`;
        const [rows] = await pool.query(sql);
        return rows;
    },

    /**
     * Busca um cliente específico pelo seu ID.
     * @async
     * @function selectClienteById
     * @param {number} pIdCliente - O ID do cliente a ser buscado.
     * @returns {Promise&lt;Array&lt;Object>>} Retorna um array (geralmente com 1 item) com os dados do cliente.
     */
    selectClienteById: async (pIdCliente) => {
        const sql = `
            SELECT 
	            id_cliente, 
	            nome, 
	            cpf, 
	            email, 
	            ender.cep, 
                ender.numero,
                ender.complemento,
	            tel.telefone
            FROM clientes cli
            join enderecos ender on cli.id_cliente = ender.clientes_id_cliente
            join telefones tel on cli.id_cliente = tel.clientes_id_cliente
            WHERE id_cliente = ?;`;
        const values = [pIdCliente]
        const [rows] = await pool.query(sql, values);
        return rows;
    },

    /**
         * Verifica se um CPF já existe no banco de dados.
         * Útil para validações antes de inserir ou atualizar.
         * @async
         * @function selectByCpf
         * @param {string} pCpf - O CPF a ser verificado.
         * @returns {Promise&lt;Array&lt;Object>>} Retorna o registro se encontrar, ou array vazio.
         */
    selectByCpf: async (pCpf) => {
        const sql = 'SELECT cpf FROM clientes WHERE cpf =?;';
        const values = [pCpf]
        const [rows] = await pool.query(sql, values);
        return rows;
    },

    /**
         * Insere um cliente, seu endereço e telefones em uma única transação atômica.
         * Se qualquer parte falhar, tudo é desfeito (Rollback).
         * @async
         * @function insertClienteCompleto
         * @param {string} pNome - Nome completo.
         * @param {string} pCpf - CPF (11 dígitos).
         * @param {string} pEmail - E-mail.
         * @param {Object} pEndereco - Objeto com dados do endereço.
         * @param {string} pEndereco.rua - Logradouro.
         * @param {string} pEndereco.bairro - Bairro.
         * @param {string} pEndereco.cidade - Cidade.
         * @param {string} pEndereco.uf - Estado (sigla).
         * @param {string} pEndereco.cep - CEP.
         * @param {string} pEndereco.numero - Número do endereço.
         * @param {string} pEndereco.complemento - Complemento.
         * @param {Array&lt;string>} pTelefones - Array contendo os números de telefone.
         * @returns {Promise&lt;Object>} Retorna o ID do novo cliente gerado: `{ id_cliente: number }`.
         * @throws {Error} Lança erro caso a transação falhe.
         */
    insertClienteCompleto: async (pNome, pCpf, pEmail, pEndereco, pTelefones) => {
        const connection = await pool.getConnection();

        try {
            await connection.beginTransaction();

            const sqlCliente = `
                INSERT INTO clientes (nome, cpf, email)
                VALUES (?, ?, ?);
            `;
            const [rows] = await connection.query(sqlCliente, [pNome, pCpf, pEmail]);

            const novoIdCliente = rows.insertId;

            const sqlEndereco = `
                INSERT INTO enderecos 
                (clientes_id_cliente, rua, bairro, cidade, uf, cep, numero, complemento)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?);
            `;

            await connection.query(sqlEndereco, [
                novoIdCliente,
                pEndereco.rua,
                pEndereco.bairro,
                pEndereco.cidade,
                pEndereco.uf,
                pEndereco.cep,
                pEndereco.numero,
                pEndereco.complemento
            ]);

            const sqlTelefone = `
                INSERT INTO telefones (telefone, clientes_id_cliente)
                VALUES (?, ?);
            `;

            for (let tel of pTelefones) {
                await connection.query(sqlTelefone, [tel, novoIdCliente]);
            }

            await connection.commit();
            return { id_cliente: novoIdCliente };

        } catch (error) {
            await connection.rollback();
            throw error;
        }
    },

    /**
     * Atualiza dados do cliente de forma dinâmica e transacional.
     * Verifica quais campos foram passados para montar a query.
     * @async
     * @function updateClienteCompleto
     * @param {number} pIdCliente - ID do cliente a ser atualizado.
     * @param {Object} pDados - Objeto contendo APENAS os campos a serem alterados (ex: nome, email, cep, telefones).
     * @returns {Promise&lt;Object>} Retorna o total de linhas afetadas e alteradas no BD.
     */
    updateClienteCompleto: async (pIdCliente, pDados) => {
        const connection = await pool.getConnection();

        try {
            await connection.beginTransaction();

            let totalAffected = 0;
            let totalChanged = 0;

            if (pDados.nome || pDados.cpf || pDados.email) {
                const campos = [];
                const valores = [];

                if (pDados.nome) { campos.push("nome = ?"); valores.push(pDados.nome); }
                if (pDados.cpf) { campos.push("cpf = ?"); valores.push(pDados.cpf); }
                if (pDados.email) { campos.push("email = ?"); valores.push(pDados.email); }

                valores.push(pIdCliente);

                const [resultCliente] = await connection.query(
                    `UPDATE clientes SET ${campos.join(", ")} WHERE id_cliente = ?`,
                    valores
                );

                totalAffected += resultCliente.affectedRows;
                totalChanged += resultCliente.changedRows;
            }

            if (pDados.cep || pDados.numero || pDados.complemento) {
                const campos = [];
                const valores = [];

                if (pDados.cep) { campos.push("cep = ?"); valores.push(pDados.cep); }
                if (pDados.numero) { campos.push("numero = ?"); valores.push(pDados.numero); }
                if (pDados.complemento) { campos.push("complemento = ?"); valores.push(pDados.complemento); }

                valores.push(pIdCliente);

                const [resultEndereco] = await connection.query(
                    `UPDATE enderecos 
                     SET ${campos.join(", ")}
                     WHERE clientes_id_cliente = ?`,
                    valores
                );

                totalAffected += resultEndereco.affectedRows;
                totalChanged += resultEndereco.changedRows;
            }

            if (pDados.telefones &amp;&amp; Array.isArray(pDados.telefones)) {
                const [delResult] = await connection.query(
                    `DELETE FROM telefones WHERE clientes_id_cliente = ?`,
                    [pIdCliente]
                );

                totalAffected += delResult.affectedRows;
                totalChanged += delResult.affectedRows;

                for (let tel of pDados.telefones) {
                    const [insertResult] = await connection.query(
                        `INSERT INTO telefones (telefone, clientes_id_cliente)
                         VALUES (?, ?)`,
                        [tel, pIdCliente]
                    );

                    totalAffected += insertResult.affectedRows;
                    totalChanged += insertResult.affectedRows;
                }
            }

            await connection.commit();

            return {
                affectedRows: totalAffected,
                changedRows: totalChanged
            };

        } catch (error) {
            await connection.rollback();
            throw error;
        }
    },

    /**
     * Remove um cliente e seus dados vinculados (Cascata manual).
     * Deleta primeiro telefones, depois endereços e por fim o cliente.
     * @async
     * @function deleteCliente
     * @param {number} pIdCliente - ID do cliente a ser excluído.
     * @returns {Promise&lt;Object>} Retorna o resultado da exclusão na tabela clientes.
     */
    deleteCliente: async (pIdCliente) => {
        const sqlTelefones = `DELETE FROM telefones WHERE clientes_id_cliente = ?;`;
        const sqlEnderecos = `DELETE FROM enderecos WHERE clientes_id_cliente = ?;`;
        const sqlClientes = `DELETE FROM clientes WHERE id_cliente = ?;`;
        const values = [pIdCliente];
        await pool.query(sqlTelefones, values);
        await pool.query(sqlEnderecos, values);
        const [rows] = await pool.query(sqlClientes, values);
        return rows;
    },


};

module.exports = { clienteModel };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-config_db.html">config/db</a></li><li><a href="module-controllers_clienteController.html">controllers/clienteController</a></li><li><a href="module-controllers_pedidoController.html">controllers/pedidoController</a></li><li><a href="module-models_clienteModel.html">models/clienteModel</a></li><li><a href="module-models_pedidoModel.html">models/pedidoModel</a></li><li><a href="module-routes_clienteRoutes.html">routes/clienteRoutes</a></li><li><a href="module-routes_index.html">routes/index</a></li><li><a href="module-routes_pedidoRoutes.html">routes/pedidoRoutes</a></li></ul><h3>Global</h3><ul><li><a href="global.html#PORT">PORT</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Wed Dec 10 2025 09:09:32 GMT-0300 (Horário Padrão de Brasília)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
